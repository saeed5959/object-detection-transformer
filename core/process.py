import redis
import json
import requests
import redis
import json
import os
import shutil

from datetime import datetime
from torch.multiprocessing import Process
from langdetect import detect, DetectorFactory

from audio_book import pdf_ai
from voice_cloner.make_model_mix import make_list_voices, make_list_voices_professional
from voice_cloner import voice_cloning, text_to_speech, make_model_mix
from voice_recognition import speech_to_text, validate_voice
from voice_denoiser import denoiser_high_noise 
from core import settings
from core.settings import LOGGER, DATASERVER, VOICES_MIX_PATH, KEY_TTS_VC_SERVICE, TTS_API, VC_API, N_STT_CORE, N_TTS_VC_SERVICE
from core.settings_load_models import LANGUAGE_CONFIG


redis_db = redis.Redis(host="localhost", port=6379, db=0)
redis_idrive = redis.Redis(host="localhost", port=6379, db=1)

DetectorFactory.seed = 0

class ValidateVoiceProcess(Process):
    """
        ValidateVoiceProcess: to run validate voice in the process
        Attributes:
            voice_address: path to the input voice
            text: input text
            language:the object of language
            key: the key generated by hashlib
    """
    def __init__(self, voice_address: str, text: str, key: str):
        super().__init__()
        self.voice_address = voice_address
        self.text = text
        self.key = key 

    def run(self) -> None:
        result = validate_voice.assess(self.voice_address, self.text)
        value = {"result": result}
        redis_db.set(self.key,json.dumps(value))
      
        
class DenoiserProcess(Process):
    """
        DenoiserProcess: to run denoiser in the process
        Attributes:
            voice_temp_addresss: path to the input voice
            result_voice_addrss: path to save the result
    """
    def __init__(self, voice_address: str, result_address: str):
        super().__init__()
        self.voice_temp_address = voice_address
        self.result_voice_addrss = result_address
        
    def run(self) -> None:
        denoiser_high_noise.denoise(self.voice_temp_address, self.result_voice_addrss)


class MakeModelProcess(Process):
    """
        MakeModelProcess: to run make model in the process
        Attributes:
            input_data: an object contains model_path, voices, gender
            key: the key generated by hashlib
    """
    def __init__(self, input_data: dict, cuda_num: int, key: str):
        super().__init__()
        self.input_data = input_data
        self.cuda_num = cuda_num
        self.key = key
 

    def run(self)-> None:
        """
            make_model
            Args :
                input_data : input params in specific class
                key : from make_model_api 
        """
        start_time = datetime.now()
        value = {"status":"RUNNING","start_time":str(start_time ),"end_time":"None","detail":"None"}
        redis_db.set(self.key, json.dumps(value))
        model_temp = os.path.join(settings.MODEL_LOCAL, self.input_data.model_path)
        voice_local = settings.VOICE_LOCAL

        try:
            voices_mix, voices = make_list_voices(VOICES_MIX_PATH[str(self.input_data.gender)], self.input_data.voices, voice_local, DATASERVER)
            make_model_mix.train(int(self.input_data.gender), voices, voices_mix, model_temp, self.cuda_num)

        except Exception as e:
            settings.LOGGER.info('EXCEPTION ERROR PROCESS: '+ str(e))
            end_time = datetime.now()
            value = {"status":"ERROR", "start_time":str(start_time),
                    "end_time":str(end_time), "detail":"make madel failed"}
            redis_db.set(self.key, json.dumps(value))
            LOGGER.error(f"make madel failed")
            return

        try:
            DATASERVER.upload(model_temp, self.input_data.model_path)
            end_time = datetime.now()
            value = {"status":"SUCCESS", "start_time":str(start_time),
                 "end_time":str(end_time), "detail":"opretion succssful"}
            redis_db.set(self.key,json.dumps(value))

        except Exception:
            model_upload = os.path.join(settings.MODEL_UPLOAD, self.input_data.model_path)
            shutil.copy(model_temp, model_upload)   
            value_idrive = {"status":"unfinished", "process":"make_model", "model_local_path": model_upload, 
                            "model_idrive_path": self.input_data.model_path}
            redis_idrive.set(self.key,json.dumps(value_idrive))
            value = {"status":"SUCCESS", "start_time":str(start_time),
                    "end_time":str(end_time), "detail":"trying to upload model"}
            redis_db.set(self.key, json.dumps(value))
            LOGGER.info("trying to upload model")


class MakeModelProfessionalProcess(Process):
    """
        MakeModelProcess: to run make model professional in the process
        Attributes:
            input_data: an object contains model_path, voices, gender
            key: the key generated by hashlib
    """
    def __init__(self, input_data: dict, voice_split_path: str, net_g: object, cuda_num: int, key: str):
        super().__init__()
        self.input_data = input_data
        self.voice_split_path = voice_split_path
        self.net_g = net_g
        self.cuda_num = cuda_num
        self.key = key
 

    def run(self)-> None:
        """
            make_model_professional
            Args :
                input_data : input params in specific class
                key : from make_model_api 
        """
        start_time = datetime.now()
        value = {"status":"RUNNING","start_time":str(start_time ),"end_time":"None","detail":"None"}
        redis_db.set(self.key, json.dumps(value))
        model_temp = os.path.join(settings.MODEL_LOCAL, self.input_data.model_path)
        voice_local = settings.VOICE_LOCAL

        try:
            
            voices_mix, voices = make_list_voices_professional(self.input_data.gender, self.input_data.voices, voice_local, self.voice_split_path, self.net_g, DATASERVER)
            make_model_mix.train(int(self.input_data.gender), voices, voices_mix, model_temp, self.cuda_num)
            

        except Exception as e:
            settings.LOGGER.info('EXCEPTION ERROR PROCESS: '+ str(e))
            end_time = datetime.now()
            value = {"status":"ERROR", "start_time":str(start_time),
                    "end_time":str(end_time), "detail":"make madel failed"}
            redis_db.set(self.key, json.dumps(value))
            LOGGER.error(f"make madel failed")
            return
        
        shutil.rmtree(self.voice_split_path)

        try:
            DATASERVER.upload(model_temp, self.input_data.model_path)
            end_time = datetime.now()
            value = {"status":"SUCCESS", "start_time":str(start_time),
                 "end_time":str(end_time), "detail":"opretion succssful"}
            redis_db.set(self.key,json.dumps(value))

        except Exception:
            model_upload = os.path.join(settings.MODEL_UPLOAD, self.input_data.model_path)
            shutil.copy(model_temp, model_upload)   
            value_idrive = {"status":"unfinished", "process":"make_model", "model_local_path": model_upload, 
                            "model_idrive_path": self.input_data.model_path}
            redis_idrive.set(self.key,json.dumps(value_idrive))
            value = {"status":"SUCCESS", "start_time":str(start_time),
                    "end_time":str(end_time), "detail":"trying to upload model"}
            redis_db.set(self.key, json.dumps(value))
            LOGGER.info("trying to upload model")


class VoiceCloningShortProcess(Process):
    """
        VoiceCloningProcess: to run voice cloning in the process
        Attributes:
            model_local: path to save the model
            input data: an object that contains text, gender and speed
            output_voice_path: the path to save the output
    """
    def __init__(self, model_lcoal: str, input_data: dict, output_voice_path: str, net_g: object):
        super().__init__()
        self.model_local = model_lcoal
        self.input_data= input_data
        self.output_voice_path = output_voice_path
        self.net_g = net_g
        self.speed = 2 - input_data.speed

    def run(self) -> None:

        n_TTS_VC_service = json.loads(redis_db.get(KEY_TTS_VC_SERVICE))
        if n_TTS_VC_service < N_TTS_VC_SERVICE:
            redis_db.set(KEY_TTS_VC_SERVICE, json.dumps(n_TTS_VC_service+1))
            try:
                requests.post(VC_API, json = {"model_local":self.model_local,"text":self.input_data.text,"gender":self.input_data.gender, 
                            "speed":self.speed, "output_voice":self.output_voice_path})
            except Exception:
                pass

            n_TTS_VC_service = json.loads(redis_db.get(KEY_TTS_VC_SERVICE))
            redis_db.set(KEY_TTS_VC_SERVICE, json.dumps(n_TTS_VC_service-1))

        else:
            try:
                voice_cloning.tts(self.model_local, self.input_data.text,
                        self.input_data.gender, self.output_voice_path, self.speed, self.net_g)
            except Exception:
                pass

class VoiceCloningLongProcess(Process):
    """
        VoiceCloningLongProcess: to run voice cloning in the process
        Attributes:
            input data: an object that contains text, id speaker and speed
            output_voice_path: the path to save the output
    """
    def __init__(self, model_lcoal: str, input_data: dict, output_voice_path: str, net_g: object, key: str):
        super().__init__()
        self.model_local = model_lcoal
        self.input_data = input_data
        self.output_voice_path = output_voice_path
        self.net_g = net_g
        self.speed = 2 - input_data.speed
        self.key = key
        
    def run(self):

        n_TTS_VC_service = json.loads(redis_db.get(KEY_TTS_VC_SERVICE))

        if n_TTS_VC_service < N_TTS_VC_SERVICE:
            redis_db.set(KEY_TTS_VC_SERVICE, json.dumps(n_TTS_VC_service+1))
            try:
                out = requests.post(VC_API, json = {"model_local":self.model_local,"text":self.input_data.text,"gender":self.input_data.gender, 
                                "speed":self.speed, "output_voice":self.output_voice_path})
                if out.status_code==200:
                    job = True    
                else:
                    job = False       
            except Exception:
                job = False

            n_TTS_VC_service = json.loads(redis_db.get(KEY_TTS_VC_SERVICE))
            redis_db.set(KEY_TTS_VC_SERVICE, json.dumps(n_TTS_VC_service-1))
            
        else:
            try:
                voice_cloning.tts(self.model_local, self.input_data.text,
                        self.input_data.gender, self.output_voice_path, self.speed, self.net_g)
                job = True
            except Exception:
                job = False
                
        if job:
            DATASERVER.upload(self.output_voice_path, self.input_data.voice_path_idrive)   
            estimate_time = json.loads(redis_db.get(self.key))["estimate_time"]
            start_time = json.loads(redis_db.get(self.key))["start_time"]
            end_time = datetime.now()
            value = {"status":"SUCCESS","start_time":str(start_time),"end_time":str(end_time),
                    "estimate_time":estimate_time,"voice_path_idrive":self.input_data.voice_path_idrive}
            redis_db.set(self.key, json.dumps(value))
            
        else:
            estimate_time = json.loads(redis_db.get(self.key))["estimate_time"]
            start_time = json.loads(redis_db.get(self.key))["start_time"]
            end_time = datetime.now()
            value = {"status":"ERROR","start_time":str(start_time),"end_time":str(end_time),
                    "estimate_time":estimate_time,"voice_path_idrive":self.input_data.voice_path_idrive}
            redis_db.set(self.key, json.dumps(value))

class TexttoSpeechShortProcess(Process):
    """
        TexttoSpeechProcess: to run text to speech in the process
        Attributes:
            input data: an object that contains text, id speaker and speed
            output_voice_path: the path to save the output
    """
    def __init__(self, input_data: dict, output_voice_path: str, net_g: object):
        super().__init__()
        self.input_data = input_data
        self.output_voice_path = output_voice_path
        self.net_g = net_g
        self.speed = 2 - self.input_data.speed

    def run(self) -> None:
        n_TTS_VC_service = json.loads(redis_db.get(KEY_TTS_VC_SERVICE))

        if n_TTS_VC_service < N_TTS_VC_SERVICE:
            redis_db.set(KEY_TTS_VC_SERVICE, json.dumps(n_TTS_VC_service+1))
            try:
                requests.post(TTS_API, json = {"text":self.input_data.text,"id_speaker":self.input_data.id_speaker, 
                            "speed":self.speed, "output_path":self.output_voice_path})      
            except Exception:
                pass

            n_TTS_VC_service = json.loads(redis_db.get(KEY_TTS_VC_SERVICE))
            redis_db.set(KEY_TTS_VC_SERVICE, json.dumps(n_TTS_VC_service-1))


        else:
            try:
                text_to_speech.tts(self.input_data.text, self.input_data.id_speaker, self.output_voice_path, self.speed, self.net_g)

            except Exception:
                pass
       

class TexttoSpeechLongProcess(Process):
    """
        TexttoSpeechLongProcess: to run text to speech in the process
        Attributes:
            input data: an object that contains text, id speaker and speed
            output_voice_path: the path to save the output
    """
    def __init__(self, input_data: dict, output_voice_path: str, net_g: object, key: str):
        super().__init__()
        self.input_data = input_data
        self.output_voice_path = output_voice_path
        self.net_g = net_g
        self.speed = 2 - input_data.speed
        self.key = key
        
    def run(self):
        n_TTS_VC_service = json.loads(redis_db.get(KEY_TTS_VC_SERVICE))

        if n_TTS_VC_service < N_TTS_VC_SERVICE:
            redis_db.set(KEY_TTS_VC_SERVICE, json.dumps(n_TTS_VC_service+1))
            try:
                out = requests.post(TTS_API, json = {"text":self.input_data.text,"id_speaker":self.input_data.id_speaker, 
                                "speed":self.speed, "output_path":self.output_voice_path})
                if out.status_code==200:
                    job = True     
                else:
                    job = False      
            except Exception:
                job = False

            n_TTS_VC_service = json.loads(redis_db.get(KEY_TTS_VC_SERVICE))
            redis_db.set(KEY_TTS_VC_SERVICE, json.dumps(n_TTS_VC_service-1))
            
        else:
            try:
                text_to_speech.tts(self.input_data.text, self.input_data.id_speaker, self.output_voice_path, self.speed, self.net_g)
                job = True
            except Exception:
                job = False
                
        if job:
            DATASERVER.upload(self.output_voice_path, self.input_data.voice_path_idrive) 
            
            estimate_time = json.loads(redis_db.get(self.key))["estimate_time"]
            start_time = json.loads(redis_db.get(self.key))["start_time"]
            end_time = datetime.now()
            value = {"status":"SUCCESS","start_time":str(start_time),"end_time":str(end_time),
                    "estimate_time":estimate_time,"voice_path_idrive":self.input_data.voice_path_idrive}
            redis_db.set(self.key, json.dumps(value))
            
        else:
            estimate_time = json.loads(redis_db.get(self.key))["estimate_time"]
            start_time = json.loads(redis_db.get(self.key))["start_time"]
            end_time = datetime.now()
            value = {"status":"ERROR","start_time":str(start_time),"end_time":str(end_time),
                    "estimate_time":estimate_time,"voice_path_idrive":self.input_data.voice_path_idrive}
            redis_db.set(self.key, json.dumps(value))


class SpeechtoTextProcess(Process):
    """
        SpeechtoTextProcess: to run speech to text in the process
        Attributes:
            input data: an object that contains language id and voice path
            key: the key generated by hashlib
    """    
    def __init__(self, voice_path: str, language_id: int, key: str):
        super().__init__()
        self.voice_path = voice_path
        self.language_id = language_id
        self.key = key

    def run(self):
        language = LANGUAGE_CONFIG.get_speech_to_text(language_id=self.language_id)
       
        try:
            text_out = speech_to_text.stt_multi(self.voice_path, N_STT_CORE, language)
            estimate_time = json.loads(redis_db.get(self.key))["estimate_time"]
            start_time = json.loads(redis_db.get(self.key))["start_time"]
            end_time = datetime.now()
            value = {"status":"SUCCESS", "start_time":str(start_time), "end_time":str(end_time),"estimate_time":estimate_time, "text":text_out}
            redis_db.set(self.key,json.dumps(value))
            
        except Exception:
            start_time = json.loads(redis_db.get(self.key))["start_time"]
            end_time = datetime.now()
            value = {"status":"ERROR", "start_time":str(start_time), "end_time":str(end_time),"estimate_time":None, "text":None}
            redis_db.set(self.key,json.dumps(value))
            
        os.remove(self.voice_path)


class PdfToTextProcess(Process):
    """
        PdfToText: convert pdf to text in process
        Attributes:
            pdf_path, pdf_folder, html_folder
    """
    def __init__(self, pdf_path: str, pdf_folder: object, html_folder: object, key: str):
        super().__init__()
        self.pdf_path = pdf_path 
        self.pdf_folder = pdf_folder
        self.html_folder = html_folder
        self.key = key
        
    def run(self) -> None:
        text = pdf_ai.extract_text(self.pdf_path, self.pdf_folder.name, self.html_folder.name)
        self.pdf_folder.cleanup()
        self.html_folder.cleanup()
    
        estimate_time = json.loads(redis_db.get(self.key))["estimate_time"]
        start_time = json.loads(redis_db.get(self.key))["start_time"]
        end_time = datetime.now()

        if (detect(text)=="en"):
            n_character = len(text)
            value = {"status":"SUCCESS","start_time":str(start_time),"end_time":str(end_time),
                 "estimate_time":estimate_time,"language":"english","text":text, "n_character":n_character}

        else :
            value = {"status":"SUCCESS","start_time":str(start_time),"end_time":str(end_time),
                 "estimate_time":estimate_time,"language":"non-english","text":None, "n_character": None}

        redis_db.set(self.key, json.dumps(value))
        
